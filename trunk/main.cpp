// -*- C++ -*- generated by wxGlade 0.5 on Tue May 29 00:24:38 2007 from Z:\WIP\CookTimer\CookTimer.wxg

#include <wx/wx.h>
#include <wx/cmdline.h>
#include <wx/tokenzr.h>
#include "CookTimerFrame.h"

class CookTimer: public wxApp
	{
	public:
		CookTimer();
		bool OnInit();
		void OnInitCmdLine(wxCmdLineParser& parser);
		bool OnCmdLineParsed(wxCmdLineParser& parser);
	
	private:
		long _hours, _minutes, _seconds;
		bool _startupParams;
		bool _autoStart;
	};

static const wxCmdLineEntryDesc g_cmdLineDesc [] =
	{
     { wxCMD_LINE_SWITCH, NULL, wxT("help"), wxT("displays help on the command line parameters"),
          wxCMD_LINE_VAL_NONE, wxCMD_LINE_OPTION_HELP },
     { wxCMD_LINE_OPTION, wxT("h"), wxT("hours"), wxT("set hours"),
          wxCMD_LINE_VAL_NUMBER, 0  },
     { wxCMD_LINE_OPTION, wxT("m"), wxT("minutes"), wxT("set minutes"),
          wxCMD_LINE_VAL_NUMBER, 0  },
     { wxCMD_LINE_OPTION, wxT("s"), wxT("seconds"), wxT("set seconds"),
          wxCMD_LINE_VAL_NUMBER, 0  },
     { wxCMD_LINE_SWITCH, wxT("ns"), wxT("nostart"), wxT("Don't start counting once launched"),
          wxCMD_LINE_VAL_NONE, 0  },
     { wxCMD_LINE_PARAM, NULL, NULL, wxT("time in the format HH:MM:SS"),
          wxCMD_LINE_VAL_STRING, wxCMD_LINE_PARAM_OPTIONAL  },
 
     { wxCMD_LINE_NONE }
	};

IMPLEMENT_APP(CookTimer)

CookTimer::CookTimer()
	: _hours(0), _minutes(0), _seconds(0),
	_startupParams(false),
	_autoStart(false)
	{
	}

void CookTimer::OnInitCmdLine(wxCmdLineParser& parser)
	{
    parser.SetDesc(g_cmdLineDesc);
	}

bool CookTimer::OnCmdLineParsed(wxCmdLineParser& parser)
	{
	_autoStart = !parser.Found(wxT("ns"));

	if (parser.GetParamCount() == 1)
		{
		_startupParams = true;
		wxString param = parser.GetParam(0);

		wxStringTokenizer tokenizer(param, wxT(":"));
		long *hms[3] = { &_hours, &_minutes, &_seconds };
		size_t startingIndex = WXSIZEOF(hms) - 1;
		if (tokenizer.CountTokens() == 3)
			{
			wprintf(wxT("Reading as HH:MM:SS\n"));
			startingIndex = 0;
			}
		else if (tokenizer.CountTokens() == 2)
			{
			wprintf(wxT("Reading as MM:SS\n"));
			startingIndex = 1;
			}
		else if (tokenizer.CountTokens() == 1)
			{
			wprintf(wxT("Reading as MM\n"));
			startingIndex = 1;
			}
		else
			{
			wprintf(wxT("Invalid Parameters\n"));
			parser.Usage();

			_startupParams = false;
			return true;
			}

		for (size_t i = startingIndex; i < 3 && tokenizer.HasMoreTokens(); i ++)
			{
			long num = 0;
			const wxString token = tokenizer.GetNextToken();
			if (!token.ToLong(&num))
				break;
			*(hms[i]) = num;
			}
		}
	else if (parser.GetParamCount() == 0)
		// Use -h/-m/-s options
		{
		if (parser.Found(wxT("hours"), &_hours) ||
			parser.Found(wxT("minutes"), &_minutes) ||
			parser.Found(wxT("seconds"), &_seconds))
			{
			_startupParams = true;
			}
		}
	else
		{
		// invalid number of parameters
		_startupParams = false;
		}

	if (_startupParams)
		wprintf(_("Timer will be set to %d hours, %d minutes and %d seconds\n"), _hours, _minutes, _seconds);

	return true;
	}

bool CookTimer::OnInit()
	{
	// call default behaviour (mandatory)
    if (!wxApp::OnInit())
        return false;

	CookTimerFrame *mainFrame = new CookTimerFrame(NULL);
	
	if (_startupParams)
		mainFrame->SetTime(_hours * 3600 +
				_minutes * 60 +
				_seconds, _autoStart);

	mainFrame->Show();
	return true;
	}
